#!/usr/bin/env python3

# Copyright (c) 2019 Anton Semjonov
# Licensed under the MIT License

import subprocess, csv, json, tempfile, sys, argparse, os, io, signal
import dateutil.parser, datetime
import dataset

# default / environment variables
DATABASE = os.environ.get("DATABASE", "sqlite:////data/speedtest.db")
PORT = os.environ.get("PORT", "8000")
SERVER = os.environ.get("TESTSERVER", None)

# commandline parser
p = argparse.ArgumentParser()
p.add_argument("-d", dest="database", help="database connection uri (env:DATABASE)", default=DATABASE)
p.add_argument("-p", dest="port", help="port to run application server on (env:PORT)", default=PORT)
p.add_argument("-l", dest="limit", help="limit number of results when dumping", default=32768)
p.add_argument("-a", dest="after", help="start dump after this date", default=None)
p.add_argument("-s", dest="server", help="take measurements against specific speedtest.net server", default=SERVER)
p.add_argument("--debug", help="enable flask debugging", action="store_true")
p.add_argument("command", choices=["serve", "measure", "dump", "import"], help="start webserver, take a measurement, dump results to csv or reimport csv data")
args = p.parse_args()

# handle ctrl-c
def quit(signum, time):
  print(" quit.")
  sys.exit(0)
signal.signal(signal.SIGINT, quit)

# connect to database
db = dataset.connect(args.database)
table = db["speedtest"]

# run a subcommand and capture its output
def run(cmd, stdin=None):
  return subprocess.run(cmd, capture_output=True, stdin=stdin)

# column names in speedtest-cli csv output
FIELDNAMES = ("Server ID", "Sponsor", "Server Name", "Timestamp", "Distance",
  "Ping", "Download", "Upload", "Share", "IP Address")

# custom exception when SpeedTest had an error
class SpeedTestError(Exception): pass

# parse the json output of taganaka/SpeedTest
def parse_measurement(js):
  if (err := js.get("error")) is not None:
    raise SpeedTestError(err)
  server, client = js.get("server", {}), js.get("client", {})
  return dict(zip(FIELDNAMES, (
    "0",
    server.get("sponsor", ""),
    server.get("name", ""),
    datetime.datetime.utcnow().isoformat(),
    server.get("distance", ""),
    js["ping"],
    js["download"],
    js["upload"],
    js.get("share", ""),
    client.get("ip", ""),
  )))

# take a new measurement with speedtest-cli
def take_measurement():
  cmd = ["SpeedTest", "--output", "json"]
  if args.server:
    cmd += ["--test-server", args.server]
  res = run(cmd)
  if res.returncode != 0:
    raise SpeedTestError(res.stderr.decode())
  r = parse_measurement(json.loads(res.stdout))
  table.insert(r)
  print(r)

# parse csv results from speedtest-cli format to dict generator
def csv_reader(reader):
  cr = csv.DictReader(reader, fieldnames=FIELDNAMES)
  for line in cr:
    if list(line.values()) == list(FIELDNAMES):
      continue # skip header line
    yield line

# output stored database rows to writer as speedtest-cli csv with header
def csv_writer(rows, writer=None):
  if writer is None:
    writer = tempfile.SpooledTemporaryFile(mode="wt+")
  wr = csv.DictWriter(writer, fieldnames=FIELDNAMES)
  wr.writeheader()
  for row in sorted(rows, key=lambda r: r["id"]):
    del row["id"]
    wr.writerow(row)
  return writer

# retrieve measurements from table applying optional filters
def retrieve_measurements(limit, after):

  # maybe use a query to filter by timestamp
  if after:
    try: after = dateutil.parser.parse(after).isoformat()
    except Exception as e:
      raise ValueError("cannot parse argument as date: " + str(e))
    return db.query("SELECT * FROM speedtest WHERE \"Timestamp\" >= :ts ORDER BY \"Timestamp\" ASC LIMIT :li", ts=after, li=limit)
  else:
    return db.query("SELECT * FROM speedtest WHERE \"Timestamp\" IS NOT NULL ORDER BY \"Timestamp\" DESC LIMIT :li", li=limit)

# just return the total number of rows
def total_measurements():
  return len(table)

def flask_server():

  # initialize flask
  import flask
  print(" * Connected database: {}".format(args.database))
  app = flask.Flask("speedtest", root_path="./")
  app.env = "development"

  # retrieve request parameters for retrieval
  def request_params(request, limit=1344): # ~ two weeks with a 15 min timer
    limit = flask.request.args.get("limit", None) or limit
    after = flask.request.args.get("after", None)
    return (limit, after)

  # scale number as mbit/s
  @app.template_filter("mbits")
  def to_mbits(d, fact=1_000_000, unit="MBit/s"):
    scaled = float(d) / fact
    return f"{scaled:.2f} {unit}"

  # homepage with rendered results
  @app.route("/")
  def home():
    try:
      limit, after = request_params(flask.request)
      rows = list(retrieve_measurements(limit, after))
      last = rows[0]
      total = total_measurements()

      TEMPLATE = """
        <!DOCTYPE html>
        <html>
          <head>
            <meta charset="utf-8">
            <title>Speedtest Plot</title>
            <style>
              input {
                box-sizing: border-box;
                border: 1px solid #000;
                border-radius: 3px;
                padding: 0.5em;
              }
              html {
                font-family: monospace;
              }
              img {
                border: 1px solid black;
                margin: 1em;
                max-width: calc(100% - 2em);
                max-height: 80vh;
              }
            </style>
          </head>
          <body>
            <center>
              <form action="/" method="get">
                Limit: <input type="number" name="limit" value="{{ limit }}" title="limit to n results">
                / <span title="total number of measurements">{{ total }}</span>,
                After: <input type="text" name="after" value="{{ after }}" title="limit to results after this date">
                <input type="submit" value="Apply">
              </form>
              <p>
                Measurement at {{ last['Timestamp'] }} to {{ last['Sponsor'] }} ({{ last['Server ID'] }})<br>
                Download: {{ last['Download'] | mbits }},
                Upload: {{ last['Upload'] | mbits }},
                Ping: {{ "%.1f" | format( last['Ping'] | float ) }} ms
              </p>
              <a href="/results.csv?limit={{ limit }}&after={{ after }}">
                {% if rows < 2 %}
                <span>Not enough measurements for a plot (yet). Here's a CSV instead.</span>
                {% else %}
                <img src="/results.svg?limit={{ limit }}&after={{ after }}">
                {% endif %}
              </a>
            </center>
          </body>
        </html>
      """
      return flask.render_template_string(TEMPLATE, args=flask.request.args, last=last, total=total, limit=limit, after=after or "", rows=len(rows))

    except Exception as e:
      err = str(e)
      if "no such table: speedtest" in err:
        err = "No measurements taken yet!\nPlease wait for cron to trigger a measurement or start one yourself with 'speedtest-plotter measure'.\n\n" + err
      print(err)
      return flask.Response(err, mimetype="text/plain", status=500)

  # retrieve spooled measurements with request params
  def spool_measurements():
    limit, after = request_params(flask.request)
    rows = retrieve_measurements(limit, after)
    spool = csv_writer(rows)
    spool.seek(0)
    return spool

  # return rendered plot picture
  @app.route("/results.svg")
  def render():
    try:
      data = spool_measurements()
      plot = run(["gnuplot", "-c", "plotscript", "/dev/stdin", "/dev/stdout"], stdin=data)
      data.close()
      if plot.returncode != 0:
        raise ValueError(plot.stderr.decode())
      return flask.Response(plot.stdout, mimetype="image/svg+xml")
    except Exception as e:
      return flask.Response(str(e), mimetype="text/plain", status=500)

  # return raw data in formatted csv
  @app.route("/results.csv")
  def results():
    try:
      data = spool_measurements()
      return flask.Response(data, mimetype="text/plain")
    except Exception as e:
      return flask.Response(str(e), mimetype="text/plain", status=500)

  app.run(threaded=False, port=args.port, host="0.0.0.0", debug=args.debug)

# ---------- main() ----------
try:

  if args.command == "serve":
    flask_server()

  elif args.command == "measure":
    take_measurement()

  elif args.command == "import":
    for m in csv_reader(sys.stdin):
      table.insert(m)
      print(m)

  elif args.command == "dump":
    rows = retrieve_measurements(args.limit, args.after)
    csv_writer(rows, sys.stdout)

  else:
    raise ValueError("unknown command: " + args.command)

except Exception as e:
  print(e)
  exit(1)
